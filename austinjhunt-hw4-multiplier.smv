-- this module computes m * n
-- based on example mult(m,n) from the Alur 2015 book
-- note: m * n must be representable in y's finite bitvector length

-- HOMEWORK 4; problem 1C

MODULE main
  VAR
    mode : {loop, stop};
    x : 0 .. 1024;
    y : 0 .. 1024;

  DEFINE m := 4;
  DEFINE n := 5;

  TRANS
    -- specify state variable updates for mode = loop and x > 0 
    ((mode = loop & x > 0) -> (next(mode) = loop & next(x) = x+(-1) & next(y) = y+n)) &
    -- specify state variable updates for mode = loop and x = 0
    ((mode = loop & x = 0) -> (next(mode) = stop & next(x) = x & next(y) = y)) & 
    -- specify state variable updates for mode = stop and x arbitrary
    ((mode = stop) -> (next(mode) = stop & next(x) = x & next(y) = y));
  INIT
    -- initialize mode to loop, x to m, y to 0 
    (mode = loop & x = m & y = 0);

INVARSPEC
  mode = loop; -- this should be false 

INVARSPEC
  y = m * n; -- this should be false, only true at the end 

INVARSPEC
  x > 0;  -- should be false, x eventually hits 0 and triggers mode switch

-- always eventually y != m * n: use to generate a counterexample
-- trace where y = m * n.
LTLSPEC
  G F y != m * n; -- should be false; once y = m * n it stays m * n

LTLSPEC
  G F (mode = stop & x = 0); -- should be true, x should always 
  -- eventually be 0 and mode should always eventually be stop when x is 0. 

-- HOMEWORK 4 PROBLEM 1D
INVARSPEC 
  -- prove that invariant from 1a is an invariant 
  -- i.e. that if mode=stop, then y = m*n
  (mode = stop) -> (y = m * n)
  -- output below:
  -- invariant (mode = stop -> y = m * n)  is true

-- HOMEWORK 4 PROBLEM 1E
-- using -bmc arg to nuxmv, show that the invariant produced as answer to 
-- 1b is indeed an inductive invariant :) 
-- this invariant is:
-- ((mode = loop) and (y = m * n - n * x)) or (mode = stop and y = m * n) 
INVARSPEC 
  ((mode = loop) & (y = m*n - n*x)) | (mode = stop & y = m * n)

-- Cool output below shows that the 1a invariant is NOT inductive but the one 
-- I produced for 1b (previous) IS inductive :) 

-- 1a induction check
-- cannot prove the invariant (mode = stop -> y = m * n)  is true or false : the induction fails
-- as demonstrated by the following execution sequence
-- Trace Description: BMC Failed Induction
-- Trace Type: Counterexample
--   -> State: 5.1 <-
--     mode = loop
--     x = 0
--     y = 0
--     m = 4
--     n = 5
--   -> State: 5.2 <-
--     mode = stop 

-- 1b induction check 
-- invariant ((mode = loop & y = m * n - n * x) | (mode = stop & y = m * n))   is true

-- HOMEWORK 4 1F; formalize and use nuXmv to prove an LTL 
-- liveness requirement that it is always the case that eventually a state where y = m * n is reached
LTLSPEC 
  G F y = m * n ; 